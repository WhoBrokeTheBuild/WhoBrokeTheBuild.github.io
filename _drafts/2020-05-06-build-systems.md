---
layout: post
title: Build Systems
excerpt: An overview of C++ Build Systems, and the reasons behind choosing CMake.
date: 2020-05-06 22:00:00 -0400
tags: 
- Game Engine
- Programming
- C++
- CMake
- Git
---

{% include game-engine-series.html %}

A logical first step when building a complex software project, like a Game Engine, is choosing a build system. This post will lay out my requirements, and then go through the build systems that I've tried.

## Requirements

* **Cross-Platform**, support for Linux, Windows, OSX. Preferably native support.
* **Dependency Management**, support for finding and/or building the libraries needed by the engine.
* **Multiple Targets**, support multiple libraries and executables, linked together in specific ways.
* **Asset Management**, support for processing and/or copying assets such as shaders, textures, models, etc.
* **Distributed Config**, support for distributing build system code throughout the project folder structure. Not being limited to one build file for everything.
* **Tests**, support for building and running unit tests, integration tests, etc.
* **Includes/Macros**, support for re-using build system code for all demos, libraries, etc.
* **Run Targets**, support for adding targets to run the demos, tests, etc. Preferably with the ability to run them through tools like `gdb`, `valgrind`, etc.
* **Packaging**, support for adding packaging targets to build `.deb`, `.zip`, etc.

## Make

Make is a very simple build system, native to Linux and OSX. Make is also ridicuously old (44 years) to be as relevant as it is. Make is used directly in many simple linux software projects, and Makefiles generated by other tools such as `cmake` or `autotools` are even more common.

Make operates on scripts, normally named `Makefile`. When `make` is run in a directory, it reads the `Makefile` and builds whatever targets are requested. If no targets are specified, it will run the default target, usually `all`.

The flexibility of make comes from the structure of rules.

```
target: dependencies
    commands
```

`target` can either be a file or a phony name. If the target is a file, it will be built when the timestamp is older than that of its dependencies, or if the file does not exist. If the target is a phony name, such as `all`, `clean`, or `test`, it will always be run.

`dependencies` is an optional list of other targets needed by this target. If the main target is requested, all targets it depends on are built.

`commands` is an optional set of commands used to build the target. Many special variables can be used to generalize your targets.

Here is a very basic `Makefile` that compiles a C++ program, and links in `SDL2`.

**Note** There are many ways to find `SDL2`, this example uses `pkg-config` and the standard name on Ubuntu. This might change based on your distribution.

```Makefile
# Targets that don't create files are called phony, so we declare 
# them explicitly
.PHONY: all clean install run gdb test

# Set the standard compiler and linker flags
CXXFLAGS += -g -Wall $(shell pkg-config --cflags sdl2)
LDFLAGS  += $(shell pkg-config --libs-only-L sdl2)
LDLIBS   += $(shell pkg-config --libs-only-l sdl2)

PREFIX ?= /usr/local

# Configure variables used by our rules
TARGET = bin/example

# Gather our source files, and a list of object file counterparts
SOURCES = $(wildcard src/**/*.cpp src/*.cpp)
OBJECTS = $(patsubst src/%.cpp, obj/%.o, $(SOURCES))

# Gather our test source files, and create a target for each of them
TEST_SOURCES = $(wildcard tests/*_test.cpp)
TEST_TARGETS = $(patsubst tests/%.cpp, bin/%, $(TEST_SOURCES))

# The general rule for building all .cpp files into .o files
# The proper way to do this would involve some flags to build a
# dependency file, usually a .d, which could track which header
# files have changed as well.
obj/%.o: src/%.cpp
	$(CXX) $(CXXFLAGS) -c -o $@ $<

# The rule for building our main target
$(TARGET): $(OBJECTS)
    $(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)

all: $(TARGET)

# Remove all targets and objects
clean:
    rm -f $(TARGET) $(OBJECTS) $(TEST_TARGETS)

# Install into the proper directory, as pointed to by
# the standard DESTDIR/PREFIX variables
install: $(TARGET)
    install -d $(DESTDIR)/$(PREFIX)/bin/
    install $(TARGET) $(DESTDIR)/$(PREFIX)/bin/

# Run our target
run: $(TARGET)
    ./$(TARGET)

# Run our target, but with gdb
gdb: $(TARGET)
    gdb --args $(TARGET)

# The rule to build each test
# In order to make this useful, you would want to build in the
# objects from the main target, or otherwise link agains the
# code you would be testing. For the point of this example,
# we're going to skip over that.
bin/%_test: tests/%_test.cpp
    $(CXX) -o $@ $<

# Build and run all of our tests
test: $(TEST_TARGETS)
    $(addsuffix ;,$(TEST_TARGETS))

```

Here is the directory structure assumed by that `Makefile`:

```
├── Makefile
├── bin/
├── obj/
├── src/
│   ├── test.hpp
│   └── main.cpp
└── tests/
    └── example_test.cpp
```

| Requirement | Ranking | Notes |
|-|-|-|
| Cross-Platform | Partial | Make is not natively supported on Windows. While you can install it, there are numerous problems and it benefits from many tools found on UNIX systems such as `pkg-config`, `find`, etc. You generally have to install a whole suite of UNIX tools on windows to make it worthwhile. |
| Dependency Management | Partial | Tools such as `pkg-config` can be invoked to get the flags needed to build against most dependencies, as long as they are installed in the system. Finding and linking against them manually is a painful process. |
| Multiple Targets | Full | Make has full support for complex dependency chains. However, to link against a target you will need to specify the proper flags to the compiler yourself. Additionally, a well-built dependency chain benefits highly from running make in parallel (`make -l` or `make -j8`). |
| Asset Management | Full | Make can be configured to 'build' any file. Adding rules to compile `%.glsl` to `%.spv` would be easy. Rules to copy files would simply use `cp`.
| Distributed Config | Full | Make can run recursively, using `make -C` to run make in a subdirectory. |
| Tests | Full | While make has no built-in support for testing, the target `test` is often used to run whatever tests the project provides. e.g. `make test`. Building tests can be done easily with a wildcard rule, however linking them against the correct object files or libraries can be cumbersome. |
| Includes/Macros | Full | Make has full support for includes, often with the file extension `.mk`. e.g. `include Common.mk`  |
| Run Targets | Full | Run targets can be easily added as phony targets with the proper command to run the target. See the above example. |
| Packaging | Full | Packaging targets can be created using standard tools such as `tar`, `dpkg-deb`, etc. |
