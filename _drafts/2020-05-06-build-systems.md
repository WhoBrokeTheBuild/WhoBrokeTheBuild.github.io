---
layout: post
title: Build Systems
excerpt: An overview of C++ Build Systems, and the reasons behind choosing CMake.
date: 2020-05-06 22:00:00 -0400
tags: 
- Game Engine
- Programming
- C++
- CMake
- Git
---

{% include game-engine-series.html %}

A logical first step when building a complicated software project, like a Game Engine, is choosing a build system. This will lay out the requirements for the project, and then go through the build systems that I tried.

## Requirements

* **Cross-Platform**, support for Linux, Windows, OSX. Preferably native support.
* **Dependency Management**, support for finding and/or building the libraries needed to build the engine.
* **Multiple Targets**, support multiple libraries and executables, linked together in specific ways.
* **Distributed Config**, support for distributing build system code throughout the project folder structure. Not being limited to one build file for everything.
* **Unit Tests**, support for building and running unit tests.
* **Includes/Macros**, support for re-using build system code for all demos, libraries, etc.
* **Run Targets**, support for adding targets to run the demos, tests, etc. Preferably with the ability to run them through tools like `valgrind`, `gdb`, etc.
* **Packaging**, support for adding packaging targets to build `.deb`, `.zip`, etc.

## Make

Make is a very simple build system, native to Linux and OSX. Make is also ridicuously old (44 years) to be as relevant as it is. Make is used directly in many simple linux software projects, and Makefiles generated by other tools such as `cmake` or `autotools` are even more common.

Make operates on scripts, normally named `Makefile`. When `make` is run in a directory, it reads the `Makefile` and builds whatever targets are requested. If no targets are specified, it will run the default target, usually `all`.

The flexibility of make comes from the structure of rules.

```
target: dependencies
    commands
```

`target` can either be a file or a phony name. If the target is a file, it will be built when the timestamp is older than that of its dependencies, or if the file does not exist. If the target is a phony name, such as `all`, `clean`, or `test`, it will always be run.

`dependencies` is an optional list of other targets needed by this target. If the main target is requested, all targets it depends on are built.

`commands` is an optional set of commands used to build the target. Many special variables can be used to generalize your targets.

Here is a very basic `Makefile` that compiles a C++ program, and links in `SDL2`.

**Note** There are many ways to find `SDL2`, this example uses `pkg-config` and the standard name on Ubuntu. This might change based on your distribution.

```Makefile
# Targets that don't create files are called phony, so we declare them explicitly
.PHONY: all clean install run gdb test

# Set the standard compiler and linker flags
CXXFLAGS += -g -Wall $(shell pkg-config --cflags sdl2)
LDFLAGS  += $(shell pkg-config --libs-only-L sdl2)
LDLIBS   += $(shell pkg-config --libs-only-l sdl2)

PREFIX ?= /usr/local

# Set variables for our target, sources, objects, etc.
TARGET = bin/example
SOURCES = $(wildcard src/**/*.cpp src/*.cpp)
OBJECTS = $(patsubst src/%.cpp, obj/%.o, $(SOURCES))

TEST_SOURCES = $(wildcard tests/%_test.cpp)
TEST_TARGETS = $(patsubst tests/%.cpp, bin/%, $(TEST_SOURCES))

# The general rule for building all .cpp files into .o files
# The proper way to do this would involve some flags to build a dependency file, usually a .d, which could track which header files have changed as well.
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp
	$(CXX) $(CXXFLAGS) -c -o $@ $<

# The rule for building our main target
$(TARGET): $(OBJECTS)
    $(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)

all: $(TARGET)

# Remove all targets and objects
clean:
    rm -f $(TARGET) $(OBJECTS) $(TEST_TARGETS)

# Install into the proper directory, as pointed to by DESTDIR/PREFIX
install: $(TARGET)
    install -d $(DESTDIR)/$(PREFIX)/bin/
    install $(TARGET) $(DESTDIR)/$(PREFIX)/bin/

# Run our target
run: $(TARGET)
    ./$(TARGET)

# Run our target, but with gdb
gdb: $(TARGET)
    gdb --args $(TARGET)

# The rule to build each test
# In order to make this useful, you would want to build in the objects from the main target, or otherwise link agains the code you would be testing. For the point of this example, we're going to skip over that.
bin/%_test: tests/%_test.cpp
    $(CXX) -o $@ $<

# Build and run all of our tests
test: $(TEST_TARGETS)
    $(addsuffix ;,$(TEST_TARGETS))

```

| Requirement | Ranking | Notes |
|-|-|-|
| Cross-Platform | Partial | Make is not natively supported on Windows. While you can install it, there are numerous problems and it's missing many of the ecosystem tools like `pkg-config` you would find on a UNIX variant. |
| Dependency Management | Partial | Tools such as `pkg-config` can be invoked to get the flags needed to build against most dependencies, as long as they are installed in the system. |
| Multiple Targets | Full | Make has full support for complex dependency chains. However, to link against a target you will need to specify the proper flags to the compiler yourself. |
| Distributed Config | Full | Use `make -C` to run make in a subdirectory. |
| Unit Tests | Full | While make has no built in support for testing, there is a very common standard of running `make test` to run whatever tests the project provides. Building tests can be done easily with a wildcard rule. |
| Includes/Macros | Full | Make has full support for includes, often with the file extension `.mk`. |
| Run Targets | Full | Run targets can be easily added as phony targets with the proper command to run the target. |
| Packaging | Full | Packaging targets can be easily created using standard tools such as `tar`, `dpkg-deb`, etc. |
