---
layout: post
title: "Build Systems: Make"
excerpt: An overview and review of the Make build system.
date: 2020-05-06 01:00:00 -0400
category: game-engine
tags: 
- Game Engine
- Programming
- C++
- Git
---

## Make

Make is a very simple build system, native to all UNIX variants (which includes Linux and OSX). Make is also ridicuously old (44 years) to be as relevant as it is. Arguably, it is not much more than a shell script with a pre-defined structure. Make adds "rules", which are analogous to functions, that can be used to create or update files. Make is the primary build system in many simple software projects, however it is more common to find Makefiles generated by other tools such as `CMake` or `autotools`.

Make operates on scripts, normally named `Makefile`. When `make` is run in a directory, it reads the `Makefile` and builds whatever targets are requested. If no targets are specified, it will run the default target, usually `all`.

The flexibility of make comes from the structure of rules.

```
target: depend
	code
```

* `target` can either be a filename or a "phony" name. If the target is a file, it will be built when the timestamp is older than that of its dependencies, or if the file does not exist. If the target is a phony name, such as `all`, `clean`, or `test`, it will always be run.
* `depend` is an optional list of other targets needed by this target. If the main target is requested, all targets it depends on are built as well.
* `code` is an optional set of shell commands used to build the target. Many special variables can be used to generalize your targets.

### Example

Here is a very basic `Makefile` that compiles a C++ program, and links it against `SDL2`.

The code used in this example can be found here:  
[https://github.com/WhoBrokeTheBuild/build-systems/tree/main/make](https://github.com/WhoBrokeTheBuild/build-systems/tree/main/make)

**Note** There are many ways to find `SDL2`, this example uses `pkg-config` and the standard name on Ubuntu. This might change based on your distribution.

```make
# Targets that don't create files are called phony, so we declare 
# them explicitly
.PHONY: all clean install run gdb test

# Ensure directories exist
$(shell mkdir -p src/ obj/ bin/)

# Set the standard compiler and linker flags
CXXFLAGS += -g -Wall $(shell pkg-config --cflags sdl2)
LDFLAGS  += $(shell pkg-config --libs-only-L sdl2)
LDLIBS   += $(shell pkg-config --libs-only-l sdl2)

PREFIX ?= /usr/local

# Configure variables used by our rules
TARGET = bin/example

# Gather our source files, and a list of object file counterparts
SOURCES = $(wildcard src/**/*.cpp src/*.cpp)
OBJECTS = $(patsubst src/%.cpp, obj/%.o, $(SOURCES))

# Gather our test source files, and create a target for each
TEST_SOURCES = $(wildcard tests/*_test.cpp)
TEST_TARGETS = $(patsubst tests/%.cpp, bin/%, $(TEST_SOURCES))

# The general rule for building all .cpp files into .o files
# The proper way to do this would involve some flags to build a
# dependency file, usually a .d, which could track which header
# files have changed as well.
obj/%.o: src/%.cpp
	$(CXX) $(CXXFLAGS) -c -o $@ $<

# The rule for building our main target
$(TARGET): $(OBJECTS)
	$(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)

all: $(TARGET)

# Remove all targets and objects
clean:
	rm -f $(TARGET) $(OBJECTS) $(TEST_TARGETS)

# Install into the proper directory, as pointed to by
# the standard DESTDIR/PREFIX variables
install: $(TARGET)
	install -d $(DESTDIR)/$(PREFIX)/bin/
	install $(TARGET) $(DESTDIR)/$(PREFIX)/bin/

# Run our target
run: $(TARGET)
	./$(TARGET)

# Run our target, but with gdb
gdb: $(TARGET)
	gdb --args $(TARGET)

# Run our target, but with valgrind
valgrind: $(TARGET)
	valgrind $(TARGET)

# The rule to build each test
# In order to make this useful, you would want to build in the
# objects from the main target, or otherwise link agains the
# code you would be testing. For the point of this example,
# we're going to skip over that.
bin/%_test: tests/%_test.cpp
	$(CXX) -I src -o $@ $<

# Build and run all of our tests
test: $(TEST_TARGETS)
	$(addsuffix ;,$(TEST_TARGETS))

```

Here is the directory structure assumed by that `Makefile`:

```
├── Makefile
├── bin/
├── obj/
├── src/
│   ├── example.hpp
│   └── main.cpp
└── tests/
    └── example_test.cpp
```

### Review

| Requirement | Ranking | Notes |
|-|-|-|
| Cross-Platform | Partial | Make is not natively supported on Windows.<br />While you can install it, there are numerous problems with doing so. In addition, `make` greatly benefits from the tools found on UNIX systems such as `pkg-config`, `find`, etc.<br />You generally have to install a whole suite of UNIX tools on windows to make it worthwhile. Visual Studio does have an equivalent, `NMake`, however it is not cross-platform at all. |
| Conditionals | Full | Make has full support for if statements. e.g. `ifeq ($(CXX), g++)` |
| Dependency Management | Partial | Tools such as `pkg-config` can be invoked to get the flags needed to build against most dependencies, as long as they are installed in the system. Finding and linking against them manually is a painful process. |
| Multiple Targets | Full | Make has full support for complex dependency chains. However, to link against a target you will need to specify the proper flags to the compiler yourself.<br />Additionally, a well-built dependency chain benefits highly from running make in parallel (`make -l` or `make -j8`). |
| Asset Management | Full | Make can be configured to 'build' any file. Adding rules to compile `%.glsl` to `%.spv` would be easy. Rules to copy files would simply use `cp`.
| Distributed Config | Full | Make can run recursively, using `make -C` to run make in a subdirectory. |
| Tests | Full | While make has no built-in support for testing, the target `test` is often used to run whatever tests the project provides. e.g. `make test`.<br />Building tests can be done easily with a wildcard rule, however linking them against the correct object files or libraries can be cumbersome. |
| Includes/Macros | Full | Make has full support for includes, often with the file extension `.mk`. e.g. `include Common.mk`  |
| Run Targets | Full | Run targets can be easily added as phony targets with the proper command to run the target. See the above example. |
| Packaging | Full | Packaging targets can be created using standard tools such as `tar`, `dpkg-deb`, etc. |

{% include game-engine-series.html %}